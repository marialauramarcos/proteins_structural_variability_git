output_file =  paste("FIGURES_REPORTS/report_comparison_families_LPD_vs_SDexp", ".html", sep = ""))
# Description:
#
# This is the main program of the project. The program simulates multiple mutants of a given protein using the "Linearly Forced -
# Elastic Network Model" (LF-ENM) with different selection regimens according to the "Stress Model". The program also
# analyzes the multiple alignment of the family to which the protein belongs and calculates measures
# of variabilty of theoretical and experimental structures.
# Experimental structures and the multiple alignment must be obtained from Homstrad.
# The difference between this program and "MainProgram.R" is that, in this case, the model considers two nodes per
# aminoacid, the alpha carbon (CA) and the center of mass of the side chain (CM).
# For the simulations using the LF-ENM, only CMs are mutated.
#
# To run the program it is necessary to previously fill the input ("input_MainProgram.csv") with the following information:
#
#    - family: The family of the protein to mutate.
#    - p.ref: The pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family. This pdbid must not be included in the dataset ("DATA/family_dataset.csv").
#    - chain.p.ref: The chain of p.ref in the pdb file obtained from Homstrad.
#    - n.mut.p: The number of mutants to generate for each member of the family. For example, if the family has 20
#    members, the program generates n.mut.p x 20 mutants.
#    - fmax: Argument for the "LF-ENM". It is the maximun value for the forces that model the mutations.
#    - R0.CA: The Cut-off for the "ANM" (Anisotropic Network Model) that represents the proteins for the CA model. Not used in this program.
#    - R0.CM: The Cut-off for the "ANM" (Anisotropic Network Model) that represents the proteins for the two nodes per site model.
#    - rotate: It can be "TRUE" or "FALSE". If it is "TRUE", r.p.2 is rotated in order to minimize RMSD with r.p.ref.
#    - heme: Argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - calculate.betas: It can be "TRUE" or "FALSE". If it is "TRUE", the program calculates betas of the "Stress Model".
#    - analyze.family: It can be "TRUE" or "FALSE". If it is "TRUE", the program analyzes the family.
#    - generate.mutants: It can be "TRUE" or "FALSE". If it is "TRUE", the program generates new mutants.
#    - analyze.experimental.theoretical: It can be "TRUE" or "FALSE". If it is "TRUE", the program analyzes the proteins.
#    - K.analysis: It can be "K" or "Keff". For "K" or "Keff", the analysis is based on normal modes of "K" or "Keff"
#    respectibly.
### PROGRAM ###
# remove objects from the workspace
rm(list = ls())
# load packages
library(bio3d)
library(seqinr)
# data dir
data.dir <- "DATA"
# set Elastic Network Model: "ANM" or "pfANM"
model <- "ANM"
# output dir
if (model == "ANM") out.dir <- "OUT/out_subset_CM_ANM"
if (model == "pfANM") out.dir <- "OUT/out_subset_CM_pfANM"
# general parameters
tolerance = 1e-10
# function filenames
AnalyzeExperimentalTheoreticalCM.fname <- "FUNCTIONS/AnalyzeExperimentalTheoreticalCM.R"
AnalyzeFamily.fname <- "FUNCTIONS/AnalyzeFamily.R"
AnalyzeAlignment.fname <- "FUNCTIONS/AnalyzeAlignment.R"
GenerateMutantsCM.fname <- "FUNCTIONS/GenerateMutantsCM.R"
ReadFasta.fname <- "FUNCTIONS/ReadFasta.R"
ReadCA.fname <- "FUNCTIONS/ReadCA.R"
ReadHeme.fname <- "FUNCTIONS/ReadHeme.R"
CalculateSideChainCM.fname <- "FUNCTIONS/CalculateSideChainCM.R"
CalculateENMKeff.fname <- "FUNCTIONS/CalculateENMKeff.R"
CalculateENMK.fname <- "FUNCTIONS/CalculateENMK.R"
CalculateVariability.fname <- "FUNCTIONS/CalculateVariability.R"
CalculateDynamicalVariability.fname <- "FUNCTIONS/CalculateDynamicalVariability.R"
CalculateDaCMCA.fname <- "FUNCTIONS/CalculateDaCMCA.R"
GetCore.fname <- "FUNCTIONS/GetCore.R"
WindowsRMSD.fname <- "FUNCTIONS/WindowsRMSD.R"
WindowsRMSDcontacts.fname <- "FUNCTIONS/WindowsRMSDcontacts.R"
if (model == "ANM") {
CalculateBetasCM.fname <- "FUNCTIONS/CalculateBetasCM.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKij.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForce.R"
}
if (model == "pfANM") {
CalculateBetasCM.fname <- "FUNCTIONS/CalculateBetasCMPFANM.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKijPFANM.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForcePFANM.R"
}
# source functions
source(AnalyzeExperimentalTheoreticalCM.fname)
source(AnalyzeFamily.fname)
source(AnalyzeAlignment.fname)
source(GenerateMutantsCM.fname)
source(ReadFasta.fname)
source(ReadCA.fname)
source(ReadHeme.fname)
source(CalculateSideChainCM.fname)
source(CalculateENMKeff.fname)
source(CalculateENMK.fname)
source(CalculateVariability.fname)
source(CalculateDynamicalVariability.fname)
source(CalculateDaCMCA.fname)
source(GetCore.fname)
source(WindowsRMSD.fname)
source(WindowsRMSDcontacts.fname)
source(CalculateBetasCM.fname)
source(CalculateKij.fname)
source(CalculateForce.fname)
# read input
input.fname <- file.path("input_MainProgram.csv")
input <- read.csv(input.fname)
# start a loop to analyze each family
for (f in (1:nrow(input))) {
family <- as.character(input$family)[f]
p.ref <- as.character(input$p.ref)[f]
chain.p.ref <- as.character(input$chain.p.ref)[f]
n.mut.p = input$n.mut.p[f]
fmax = input$fmax[f]
R0 = input$R0.CM[f]
rotate <- input$rotate[f]
heme <- input$heme[f]
calculate.betas <- input$calculate.betas[f]
analyze.family <- input$analyze.family[f]
generate.mutants <- input$generate.mutants[f]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[f]
K.analysis <- input$K.analysis[f]
print(family)
# analyze the alignment of the family
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# get the core of the alignment
GetCore(family,
data.dir,
p.ref)
# calculate distances to the active site
CalculateDaCMCA(family,
p.ref,
chain.p.ref,
heme,
data.dir,
out.dir)
# generate id for betas output filename
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
# calculate betas of the "Stress Model"
if (calculate.betas == "TRUE") {
CalculateBetasCM(chain.p.ref,
fmax,
R0,
heme,
data.dir,
out.dir,
betas.fname.id,
tolerance)
}
# read betas and stablish selection regimens
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
regimens <- c("strong.sel", "medium.sel", "weak.sel", "no.sel")
# start a loop for each beta
for (b in all.betas)  {
# filter regimens
if (regimens[all.betas == b] != "weak.sel") {
if (regimens[all.betas == b] != "strong.sel") {
# generate ids for output filenames
mut.fname.id <- paste(family, "_R0_", R0, "_beta_", regimens[all.betas == b], sep = "")
analysis.fname.id <- paste(mut.fname.id, "_K.analysis_", K.analysis, sep = "")
# generate mutants
if (generate.mutants == "TRUE") {
GenerateMutantsCM(family,
chain.p.ref,
n.mut.p,
fmax,
R0,
b,
heme,
data.dir,
out.dir,
mut.fname.id,
tolerance)
}
# calculate measures of variability of theoretical and experimental proteins
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoreticalCM(family,
p.ref,
chain.p.ref,
n.mut.p,
R0,
rotate,
heme,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
tolerance)
}
}
}
}
}
input
f = 2
family <- as.character(input$family)[f]
p.ref <- as.character(input$p.ref)[f]
chain.p.ref <- as.character(input$chain.p.ref)[f]
n.mut.p = input$n.mut.p[f]
fmax = input$fmax[f]
R0 = input$R0.CM[f]
rotate <- input$rotate[f]
heme <- input$heme[f]
calculate.betas <- input$calculate.betas[f]
analyze.family <- input$analyze.family[f]
generate.mutants <- input$generate.mutants[f]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[f]
K.analysis <- input$K.analysis[f]
print(family)
# analyze the alignment of the family
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# get the core of the alignment
GetCore(family,
data.dir,
p.ref)
# calculate distances to the active site
CalculateDaCMCA(family,
p.ref,
chain.p.ref,
heme,
data.dir,
out.dir)
# generate id for betas output filename
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
# calculate betas of the "Stress Model"
if (calculate.betas == "TRUE") {
CalculateBetasCM(chain.p.ref,
fmax,
R0,
heme,
data.dir,
out.dir,
betas.fname.id,
tolerance)
}
# read betas and stablish selection regimens
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
regimens <- c("strong.sel", "medium.sel", "weak.sel", "no.sel")
# start a loop for each beta
for (b in all.betas)  {
# filter regimens
if (regimens[all.betas == b] != "weak.sel") {
if (regimens[all.betas == b] != "strong.sel") {
# generate ids for output filenames
mut.fname.id <- paste(family, "_R0_", R0, "_beta_", regimens[all.betas == b], sep = "")
analysis.fname.id <- paste(mut.fname.id, "_K.analysis_", K.analysis, sep = "")
# generate mutants
if (generate.mutants == "TRUE") {
GenerateMutantsCM(family,
chain.p.ref,
n.mut.p,
fmax,
R0,
b,
heme,
data.dir,
out.dir,
mut.fname.id,
tolerance)
}
# calculate measures of variability of theoretical and experimental proteins
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoreticalCM(family,
p.ref,
chain.p.ref,
n.mut.p,
R0,
rotate,
heme,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
tolerance)
}
}
}
}
# load packages
library(knitr)
library(markdown)
# read input
input.fname <- "input_MainReport.csv"
input <- read.csv(input.fname)
input
f = 4
R0
family <- as.character(input$family)[f]
type <- as.character(input$type)[f]
p.ref <- as.character(input$p.ref)[f]
n.mut.p <- input$n.mut.p[f]
R0.CA = input$R0.CA[f]
R0.CM = input$R0.CM[f]
chain.p.ref <- as.character(input$chain.p.ref)[f]
K.analysis <- input$K.analysis[f]
print(family)
R0.CM
R0.CM = 12.5
## ANM CA
data.dir <- "OUT/out_subset_CA_ANM"
out.dir <- "FIGURES_REPORTS"
enm <- "ANM"
R0 = R0.CA
## CM
data.dir <- paste("OUT/out_subset_CM_ANM", sep = "")
out.dir <- "FIGURES_REPORTS"
enm <- "ANM"
R0 = R0.CM
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
P.REF
p.ref
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
p.ref
library(reshape2)
library(plyr)
library(bio3d)
# load functions
source(file.path(data.dir, "multiplot.R"))
source(file.path(data.dir, "my-functions.R"))
source("FUNCTIONS/CalculateENMKeff.R")
source("FUNCTIONS/CalculateENMK.R")
source("FUNCTIONS/CalculateSideChainCM.R")
source("FUNCTIONS/readCA.R")
myColors = c("blue", "darkgreen", "darkgreen", "red", "red")
names(myColors) <- c("exp", "mut", "no-selection", "medium", "selection")
# set significance factors
f95 = 1.96
f99 = 2.6
f999 = 3.3
tolerance = 1e-10
# set input filenames
## data
reference.fname = file.path(data.dir, paste(family, "_ref.txt", sep = ""))
protein_list.fname = file.path(data.dir, paste(family, "_list.txt", sep = ""))
site.info.fname = file.path(data.dir, paste(p.ref, "_m.da.ca.csv", sep = ""))
functional.sites.fname = file.path("DATA", paste(p.ref, "_functionalSites.csv", sep = ""))
asa.fname = file.path("DATA", paste(p.ref, "_dssp.csv", sep = ""))
surfase.area.fname = file.path("DATA", "surfase_area.csv")
## profiles to compare
dri2.exp.fname = file.path(data.dir, paste(family, "_R0_", R0, "_beta_no.sel_K.analysis_Keff_out_m.exp.norm.dr.squarei.csv", sep = ""))
dri2.medium.fname = file.path(data.dir, paste(family, "_R0_", R0, "_beta_medium.sel_K.analysis_Keff_out_m.theo.norm.dr.squarei.csv", sep = ""))
dri2.mut.fname = file.path(data.dir,paste(family, "_R0_", R0, "_beta_no.sel_K.analysis_Keff_out_m.theo.norm.dr.squarei.csv", sep = ""))
## score
score.fname = file.path(data.dir, paste(p.ref, "_consurf.csv", sep = ""))
sim.data.mut.fname = file.path(data.dir, paste(family, "_R0_", R0, "_beta_no.sel_out_df.data.csv", sep = ""))
sim.data.medium.sel.fname = file.path(data.dir, paste(family, "_R0_", R0, "_beta_medium.sel_out_df.data.csv", sep = ""))
reference = as.character(read.table(reference.fname, header = F)[1, 1])
if (reference != p.ref) {
print("Warning: different references")
}
# which are the functional sites?
functional.sites = read.csv(functional.sites.fname, sep = ";")
active.site.index = functional.sites$index
description = functional.sites$description
function.info = data.frame(active.site.index, description)
## asa or acc of p.ref
asa = read.csv(asa.fname, sep = ";")
ACC = asa$ACC
AA = asa$AA
## surfase area of AA
surfase.area = read.csv(surfase.area.fname, sep = ";")
AA.CODE = surfase.area$X1.LETTER.AA.CODE
SURFASE.AREA = surfase.area$SURFASE.AREA
# calculate RSA
RSA = c()
for (i in (1:length(AA))) {
RSA[i] = ACC[i]/SURFASE.AREA[which(AA.CODE == as.character(AA[i]))]
}
protein.exp = read.table(protein_list.fname, header = F, stringsAsFactors = F)[, 1]
protein.exp = protein.exp[protein.exp != reference]
print(protein.exp)
# read site information of the reference protein
site.info = read.csv(site.info.fname, header = T, sep = ",")
# add info to site.info
d = ddply(site.info, "site", .fun = function(x) data.frame("da" = min(x[, c(-1, -2)])))
# define shells of active.sites site neighborhood
d$shell = cut(d$da, breaks = c(-.1, 2.5, 7.5, 12.5, 17.5, 22.5, 27.5, 32.5, 37.5, 42.5, 47.5, 52.5, max(d$da)))
levels(d$shell) = seq(length(levels(d$shell))) - 1 # rename shell levels
site.info = merge(site.info, d, by = "site")
# read reference pdb and calculate resno, AA, and CN
reference.pdb.fname = file.path(data.dir,paste(reference, ".pdb", sep = ""))
ref.pdb = read.pdb(reference.pdb.fname)
inds = atom.select(ref.pdb, elety = "CA")
ref.pdb
inds = atom.select(ref.pdb, elety = "CA")
ref.pdb.ca = ref.pdb$atom[inds$atom,]
r.p.ref = ref.pdb$xyz[inds$xyz]
cmap.ca = cmap(ref.pdb$xyz[inds$xyz], dcut = R0, scut = 0, mask.lower = F)
CN = rowSums(cmap.ca, na.rm = T) - 1 # diag(cmap.ca) returned by cmap is 1
n.sites = length(CN)
AA = ref.pdb.ca$resid
resno = ref.pdb.ca$resno
# calculate WCN
r.p.ref = matrix(ref.pdb$xyz[inds$xyz], nrow = 3)
dist.r.p.ref = dist.xyz(t(r.p.ref))
WCN = c()
for (i in (1:ncol(r.p.ref))) {
WCN[i] = sum(1/dist.r.p.ref[i, -i]^2)
}
WCN
# correct active site index
active.site.index.n = c()
for (i in (1:length(active.site.index))) {active.site.index.n = c(active.site.index.n, which(resno == active.site.index[i]))}
active.sites = active.site.index.n
# find the active site contacts
contacts.active.sites = d$site[d$shell == 1]
# read CM data
if ((data.dir == "OUT/out_subset_CM_ANM") | (data.dir == "OUT/out_subset_CM_pfANM")){
# Read PDB of p.ref
pdb.ca = ReadCA(reference.pdb.fname, chain.p.ref)
r.ca.p.ref = pdb.ca$xyz.calpha
n.aa = pdb.ca$n.sites
r.CM.p.ref = CalculateSideChainCM(reference.pdb.fname, chain.p.ref)
n.CM = ncol(r.CM.p.ref)
r.p.ref = c(r.ca.p.ref, as.vector(r.CM.p.ref))
cmap.CM = cmap(r.p.ref, dcut = R0, scut = 0, mask.lower = F)[1:n.aa, ]
CN = rowSums(cmap.CM, na.rm = T) - 2
WCN = c()
for (i in (1:ncol(r.p.ref))) {
WCN[i] = sum(1/dist.r.p.ref[i, -c(i, (i + ncol(r.CM.p.ref)))] ^ 2)
}
}
r.ca.p.ref
n.aa
r.CM.p.ref
r.CM.p.ref = CalculateSideChainCM(reference.pdb.fname, chain.p.ref)
n.CM = ncol(r.CM.p.ref)
r.p.ref = c(r.ca.p.ref, as.vector(r.CM.p.ref))
r.p.ref
91*2*3
cmap.CM = cmap(r.p.ref, dcut = R0, scut = 0, mask.lower = F)[1:n.aa, ]
CN = rowSums(cmap.CM, na.rm = T) - 2
WCN = c()
for (i in (1:ncol(r.p.ref))) {
WCN[i] = sum(1/dist.r.p.ref[i, -c(i, (i + ncol(r.CM.p.ref)))] ^ 2)
}
ncol(r.p.ref)
WCN = c()
r.p.ref = matrix(r.p.ref, nrow = 3)
dist.r.p.ref = dist.xyz(t(r.p.ref))
for (i in (1:ncol(r.p.ref))) {
WCN[i] = sum(1/dist.r.p.ref[i, -c(i, (i + ncol(r.CM.p.ref)))] ^ 2)
}
WCN
CN
WCN = c()
r.p.ref = matrix(r.p.ref, nrow = 3)
dist.r.p.ref = dist.xyz(t(r.p.ref))
for (i in (1:ncol(r.p.ref))) {
WCN[i] = sum(1/dist.r.p.ref[i, -c(i, (i + ncol(r.CM.p.ref)))] ^ 2)[1:n.aa, ]
}
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
enm == "pfANM"
enm == "ANM"
CalculateKij
if ((data.dir == "OUT/out_subset_CA_ANM") | (data.dir == "OUT/out_subset_CA_pfANM")) {
## calculate ENM CA
print("T")}
matrix(r.p.ref, nrow = 3)
seq(1:n.sites)
seq((n.sites + 1):ncol(matrix(r.p.ref, nrow = 3)))
seq((n.sites + 1);ncol(matrix(r.p.ref, nrow = 3)))
seq((n.sites + 1),ncol(matrix(r.p.ref, nrow = 3)))
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
seq((n.sites + 1);ncol(matrix(r.p.ref, nrow = 3)))
ENMK.p.ref = CalculateENMKeff(matrix(r.p.ref, nrow = 3),
seq(1:n.sites),
seq((n.sites + 1),ncol(matrix(r.p.ref, nrow = 3))),
R0,
tolerance,
K.analysis)
## get cov matrix
cov.p.ref = ENMK.p.ref$cov
## get the diagonal of the cov matrix
diag.p.ref = diag(cov.p.ref)
## calculate the factor to split the diagonal
factor = sort(rep(seq(1:n.sites), 3))
## split the diagonal
s.diag.p.ref = split(diag.p.ref, factor)
## create a matrix to save the data
MSF.p.ref = matrix(nrow = 1, ncol = n.sites)
## start a loop to calculate sums for each site
for (i in (1:n.sites)) {
MSF.p.ref[, i] = sum(unlist(s.diag.p.ref[i]), use.names = F)
}
## transform to a vector
MSF.p.ref = as.vector(MSF.p.ref)
MSF.p.ref
if((data.dir == "OUT/out_subset_CM_ANM") | (data.dir == "OUT/out_subset_CM_pfANM")) {
print("T")
}
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))
### Structure - Cartesian coordinates analysis
rmarkdown::render('analysis-structure.Rmd',
output_file =  paste(out.dir, "/report_structure_CM_", family, "_", enm, "_R0_", R0, ".html", sep = ''))

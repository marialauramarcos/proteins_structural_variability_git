{
    "contents" : "# This function analyzes experimental and theoretical data calculating measures of variability \n# of experimental proteins and simulated mutants respectibly. \n# \n#  Args:\n#    family: the family of p.ref.\n#    exp.chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.\n#    n.mut.p: the number of simulated mutants generated for each protein of the family.\n#    R0: cut-off for the ANM.\n#    rotate: it can be \"TRUE\" or \"FALSE\". If it is \"TRUE\", r.p.2 is rotaded in order to minimize RMSD with r.p.ref.\n#    core: it can be \"TRUE\" or \"FALSE\". If it is \"TRUE\", the program only considers the conserved core of \n#    the alignment. If it is \"FALSE\", the program analyzes the whole alignment.\n#    heme: argument for globins. It can be \"TRUE\" or \"FALSE\". If it is \"TRUE\", the program considers the heme group. \n#    natural.selection: It can be \"TRUE\" or \"FALSE\". If it is \"TRUE\" the mutants are calculated considering natural \n#    selection. If it is \"FALSE\" the mutants are calculated in a random manner.\n#    K.analysis: It can be \"K\" or \"Keff\". For \"K\" or \"Keff\", the analysis is based on normal modes of \"K\" or \"Keff\"\n#    respectibly.\n#    data.dir: directory of the data. It must contain the file with the dataset (\"data.dir/family_dataset.csv\") and the pdb file \n#    obtained from Homstrad (\"data.dir/family_coordinates.csv\").\n#    out.dir: directory of the output. It must contain output files generated with AnalyzeFamily() and GenerateMutants().\n#    The output of this function is also saved in out.dir.\n#    mut.fname.id: ID of filnames of mutant proteins.\n#    analysis.fname.id: ID of output filenames.\n#    TOLERANCE: 0 tolerance.\n#\n#  Requires:\n#    ReadCA\n#    ReadHeme\n#    CalculateVariability\n#    CalculateENMKeff\n#    CalculateENMK\n#\n#  Returns:\n#    File with m.exp.va in out.dir.\n#    File with m.exp.Pn in out.dir.\n#    File with m.exp.dr.squarei in out.dir.\n#    File with m.theo.va in out.dir.\n#    File with m.theo.Pn in out.dir.\n#    File with m.theo.dr.squarei in out.dir.\n\nAnalyzeExperimentalTheoretical <- function(family,\n                                           exp.chain.p.ref,\n                                           n.mut.p,\n                                           R0, \n                                           core,\n                                           rotate,\n                                           heme,\n                                           natural.selection,\n                                           K.analysis,\n                                           data.dir,\n                                           out.dir,\n                                           mut.fname.id, \n                                           analysis.fname.id,\n                                           TOLERANCE) {\n  # Filenames.\n  dataset.fname <- file.path(data.dir, paste(family, \"_dataset.csv\", sep = \"\"))\n  pdbs.fname <- file.path(data.dir, paste(family, \"_coordinates.pdb\", sep = \"\")) \n  \n  m.n.aligned.fname <- file.path(out.dir, paste(family, \"_out_m.n.aligned.csv\", sep = \"\"))\n  m.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, \"_out_m.aligned.p.ref.index.csv\", sep = \"\"))\n  m.aligned.p.2.index.fname <- file.path(out.dir, paste(family, \"_out_m.aligned.p.2.index.csv\", sep = \"\"))\n  m.not.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, \"_out_m.not.aligned.p.ref.index.csv\", sep = \"\"))\n  m.not.aligned.p.2.index.fname <- file.path(out.dir, paste(family, \"_out_m.not.aligned.p.2.index.csv\", sep = \"\"))\n  \n  m.n.core.fname <- file.path(out.dir, paste(family, \"_out_m.n.core.csv\", sep = \"\"))\n  m.core.p.ref.index.fname <- file.path(out.dir, paste(family, \"_out_m.core.p.ref.index.csv\", sep = \"\"))\n  m.core.p.2.index.fname <- file.path(out.dir, paste(family, \"_out_m.core.p.2.index.csv\", sep = \"\"))\n  m.no.core.p.ref.index.fname <- file.path(out.dir, paste(family, \"_out_m.no.core.p.ref.index.csv\", sep = \"\"))\n  m.no.core.p.2.index.fname <- file.path(out.dir, paste(family, \"_out_m.no.core.p.2.index.csv\", sep = \"\"))\n  \n  m.r.mut.fname <- file.path(out.dir, paste(mut.fname.id, \"_out_m.r.mut.csv\", sep = \"\"))\n  theo.r.p.ref.fname <- file.path(out.dir, paste(mut.fname.id, \"_out_r.p.ref.csv\", sep = \"\"))\n  \n  # Read dataset.\n  dataset <- read.csv(dataset.fname)\n  pdbid.dataset <- as.character(dataset$pdbid) \n  exp.chain <- as.character(dataset$chain)\n  n.prot = length(pdbid.dataset)\n  \n  # Read pdb of exp.p.ref.\n  exp.pdb.p.ref = ReadCA(pdbs.fname, exp.chain.p.ref)\n  exp.r.p.ref = exp.pdb.p.ref$xyz.calpha\n  n.aa.p.ref = exp.pdb.p.ref$n.sites\n  \n  # Read indexes files.\n  m.n.aligned = read.csv(m.n.aligned.fname)\n  m.aligned.p.ref.index = read.csv(m.aligned.p.ref.index.fname)\n  m.aligned.p.2.index = read.csv(m.aligned.p.2.index.fname)\n  m.not.aligned.p.ref.index = read.csv(m.not.aligned.p.ref.index.fname)\n  m.not.aligned.p.2.index = read.csv(m.not.aligned.p.2.index.fname)\n  \n  m.n.core = read.csv(m.n.core.fname)\n  m.core.p.ref.index = read.csv(m.core.p.ref.index.fname)\n  m.core.p.2.index = read.csv(m.core.p.2.index.fname)\n  m.no.core.p.ref.index = read.csv(m.no.core.p.ref.index.fname)\n  m.no.core.p.2.index = read.csv(m.no.core.p.2.index.fname)\n  \n  # Read coordinates of theo.p.ref and the simulated mutants.\n  m.r.mut = read.csv(m.r.mut.fname)\n  theo.r.p.ref = read.csv(theo.r.p.ref.fname)$x\n  n.sites.p.ref = length(theo.r.p.ref)/3\n\n  # Create matrices to save measures of variability of each mutant.\n  m.exp.Pn = matrix(nrow = n.prot, ncol = 3 * n.sites.p.ref)\n  m.exp.va = matrix(nrow = n.prot, ncol = 3 * n.sites.p.ref)\n  m.exp.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)\n  m.exp.smooth.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)\n  \n  m.theo.Pn = matrix(nrow = n.prot * n.mut.p, ncol = 3 * n.sites.p.ref)\n  m.theo.va = matrix(nrow = n.prot * n.mut.p, ncol = 3 * n.sites.p.ref)\n  m.theo.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)\n  m.theo.smooth.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)\n  \n  # Start a loop to evaluate each protein of the family.\n  for (P in (1:n.prot)) {\n    print(P)\n    \n    # Get aligned and not aligned indexes.\n    if (core == \"FALSE\") {\n      n.aligned = as.numeric(m.n.aligned[P, ])\n      aligned.p.ref.index = as.numeric(m.aligned.p.ref.index[P, !is.na(m.aligned.p.ref.index[P, ])])\n      aligned.p.2.index = as.numeric(m.aligned.p.2.index[P, !is.na(m.aligned.p.2.index[P, ])])\n      not.aligned.p.ref.index = as.numeric(m.not.aligned.p.ref.index[P, !is.na(m.not.aligned.p.ref.index[P, ])])\n      not.aligned.p.2.index = as.numeric(m.not.aligned.p.2.index[P, !is.na(m.not.aligned.p.2.index[P, ])])\n    } else {\n      n.aligned = as.numeric(m.n.core[P, ]) \n      aligned.p.ref.index = as.numeric(m.core.p.ref.index[P, !is.na(m.core.p.ref.index[P, ])])\n      aligned.p.2.index = as.numeric(m.core.p.2.index[P, !is.na(m.core.p.2.index[P, ])])\n      not.aligned.p.ref.index = as.numeric(m.no.core.p.ref.index[P, !is.na(m.no.core.p.ref.index[P, ])])\n      not.aligned.p.2.index = as.numeric(m.no.core.p.2.index[P, !is.na(m.no.core.p.2.index[P, ])])\n    }\n    \n    # Read PDB of exp.p.2.  \n    exp.chain.p.2 <- exp.chain[[P]]\n    exp.pdb.p.2 = ReadCA(pdbs.fname, exp.chain.p.2)\n    exp.r.p.2 = exp.pdb.p.2$xyz.calpha\n    exp.n.aa.p.2 = exp.pdb.p.2$n.sites\n    \n    # Calculate heme coordinates, add them to CAÂ´s coordinates and calculate the number of sites and not aligned indexes.\n    if (heme == \"TRUE\") {\n      if (P == 1) {\n        exp.r.heme.p.ref = ReadHeme(pdbs.fname, exp.chain.p.ref)\n        exp.r.p.ref = cbind(exp.r.p.ref, exp.r.heme.p.ref)\n        n.sites.p.ref = ncol(exp.r.p.ref)\n      }\n      exp.r.heme.p.2 = ReadHeme(pdbs.fname, exp.chain.p.2)\n      exp.r.p.2 = cbind(exp.r.p.2, exp.r.heme.p.2)\n      exp.n.sites.p.2 = ncol(exp.r.p.2)\n      \n      not.aligned.p.ref.index <- c(not.aligned.p.ref.index, t(seq((n.aa.p.ref + 1), n.sites.p.ref)))\n      not.aligned.p.2.index <- c(not.aligned.p.2.index, t(seq((exp.n.aa.p.2 + 1), exp.n.sites.p.2)))\n    }\n    \n    # Calculate measures of variavility for exp.\n    exp.variability = CalculateVariability(as.vector(exp.r.p.ref), \n                                           as.vector(exp.r.p.2), \n                                           aligned.p.ref.index, \n                                           aligned.p.2.index, \n                                           not.aligned.p.ref.index,\n                                           not.aligned.p.2.index,\n                                           R0,\n                                           rotate,\n                                           K.analysis,\n                                           TOLERANCE)\n    \n    m.exp.va[P, 1:length(exp.variability$va)] = exp.variability$va\n    m.exp.Pn[P, 1:length(exp.variability$Pn)] = exp.variability$Pn\n    exp.dr.squarei = exp.variability$dr.squarei\n    for (i in (1:n.sites.p.ref)) {\n      m.exp.dr.squarei[P, i] = matrix(exp.dr.squarei[ aligned.p.ref.index == i], nrow = 1, ncol = 1)\n    }\n    \n    # Calculate smooth dr.squarei.\n    kij = CalculateENMK(exp.r.p.ref, CalculateKij, R0, TOLERANCE)$kij\n    m.exp.dr.squarei.0 = m.exp.dr.squarei[P, ]\n    m.exp.dr.squarei.0[is.na(m.exp.dr.squarei.0)] = TOLERANCE\n    m.exp.smooth.dr.squarei[P, ] = (m.exp.dr.squarei[P, ] +  (kij %*%  m.exp.dr.squarei.0)) / rowSums(kij[, !is.na(m.exp.dr.squarei[P, ])])\n    m.exp.smooth.dr.squarei[P, ] = m.exp.smooth.dr.squarei[P, ]/ sum(m.exp.smooth.dr.squarei[P, ], na.rm = T)\n    for (mut in (1:n.mut.p)) {\n    print(c(P, mut))\n      \n      P.mut = n.mut.p * P - (n.mut.p - mut)\n      \n      # Get theo.r.p.2.\n      theo.r.p.2 = m.r.mut[, P.mut]\n    \n      # Calculate measures of variavility for theo.\n        theo.variability = CalculateVariability(as.vector(theo.r.p.ref), \n                                                as.vector(theo.r.p.2), \n                                                seq(1, n.sites.p.ref), \n                                                seq(1, n.sites.p.ref), \n                                                c(),\n                                                c(),\n                                                R0,\n                                                rotate,\n                                                K.analysis,\n                                                TOLERANCE)\n      \n      m.theo.va[P.mut, 1:length(theo.variability$va)] = theo.variability$va\n      m.theo.Pn[P.mut, 1:length(theo.variability$Pn)] = theo.variability$Pn\n      m.theo.dr.squarei[P.mut, 1:length(theo.variability$dr.squarei)] = theo.variability$dr.squarei\n      \n      # Calculate smooth dr.squarei.\n      kij = CalculateENMK(matrix(theo.r.p.ref, nrow = 3), CalculateKij, R0, TOLERANCE)$kij\n      m.theo.dr.squarei.0 = m.theo.dr.squarei[P.mut, ]\n      m.theo.dr.squarei.0[is.na(m.theo.dr.squarei.0)] = TOLERANCE\n      m.theo.smooth.dr.squarei[P.mut, ] = (m.theo.dr.squarei[P.mut, ] +  (kij %*%  m.theo.dr.squarei.0)) / rowSums(kij[, !is.na(m.theo.dr.squarei[P.mut, ])])\n      m.theo.smooth.dr.squarei[P.mut, ] = m.theo.smooth.dr.squarei[P.mut, ]/ sum(m.theo.smooth.dr.squarei[P.mut, ], na.rm = T)\n    } \n  }\n  \n  # Create files to save the data.\n  write.csv(m.exp.va, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.exp.va.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.exp.Pn, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.exp.Pn.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.exp.dr.squarei, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.exp.dr.squarei.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.exp.smooth.dr.squarei, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.exp.smooth.dr.squarei.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.theo.va, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.theo.va.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.theo.Pn, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.theo.Pn.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.theo.dr.squarei, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.theo.dr.squarei.csv\", sep = \"\")), row.names = FALSE)\n  write.csv(m.theo.smooth.dr.squarei, file = file.path(out.dir, paste(analysis.fname.id, \"_out_m.theo.smooth.dr.squarei.csv\", sep = \"\")), row.names = FALSE)\n}\n\n",
    "created" : 1459004717618.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3747310772",
    "id" : "3B655091",
    "lastKnownWriteTime" : 1459003842,
    "path" : "C:/Users/Laurita/Desktop/Doctorado/VariabilidadEstructuralProteica/FUNCTIONS/AnalyzeExperimentalTheoretical.R",
    "project_path" : "FUNCTIONS/AnalyzeExperimentalTheoretical.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}
# Description:
#
# This function generates multiple mutants of a given protein using the LF-ENM ("Linearly Forced - Elastic Network Model")
# and considering additive single mutations. It calculates the probability of acceptance of each single mutation
# following the "Stress Model" and given the value of the parameter "beta". The function accepts each mutation according to the 
# calculated probability. 
# The program calculates simulated mutants with the number of mutations that corresponds to the <%id> of the familiy.
#
# Usage:
#
# GenerateMutants(family, chain.p.ref, n.mut.p, fmax, R0, beta, heme = TRUE/FALSE, data.dir, out.dir,
# mut.fname.id, tolerance)
#
#  Args:
#    - family: the family of the protein to mutate. It can be "globins", "serinProteases", 
#    "snakesToxin", "sh3", "fabp", "rrm", "phoslip" or "cys".
#    - chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.
#    - n.mut.p: the number of mutants to generate for each member of the family. For example, if the family has 20 
#    members, the function generates n.mut.p x 20 mutants.
#    - fmax: It is the maximun value for the forces that model the mutations.
#    - R0: the cut-off for the ANM ("Anisotropic Network Model") that represents the proteins.
#    - beta: parameter for the selection following the Stress Model.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - data.dir: directory of the data. It must contain the pdb file obtained from Homstrad ("data.dir/family_coordinates.csv").
#    - out.dir: output directory. It must contain the output generated by the function AnalyzeFamily().
#    - mut.fname.id: ID for output filenames.
#    - tolerance: 0 tolerance.
#
#  Required libraries:
#    {Bio3d}
#
#  Required function:
#    ReadCA()
#    ReadHeme()
#    CalculateENMK()
#    CalculateKij()
#    CalculateForce()

GenerateMutants <- function(family,
                            chain.p.ref,
                            n.mut.p,
                            fmax, 
                            R0,
                            beta,
                            heme,
                            data.dir,
                            out.dir,
                            mut.fname.id,
                            tolerance) {
  
  print("generating mutants...")
  
  ### READ EXPERIMENTAL DATA ###

  # Filenames
  m.identity.fname <- file.path(out.dir, paste(family, "_out_m.identity.csv", sep = ""))
  pdbs.fname <- file.path(data.dir, paste(family, "_coordinates.pdb", sep = "")) 
  
  # Read the file with % sequence identity between p.ref and the other proteins of the family
  m.identity = read.csv(m.identity.fname)$V1
  
  # Calculate the number of proteins of the family
  n.prot = length(m.identity)
  
  # Read PDB of p.ref
  pdb = ReadCA(pdbs.fname, chain.p.ref)
  r.p.ref = pdb$xyz.calpha
  n.aa = pdb$n.sites
  
  # Get heme coordinates, add them to CAB4s coordinates and calculate the new number of sites
  if (heme == "TRUE") {
    r.heme = ReadHeme(pdbs.fname, chain.p.ref)
    r.p.ref = cbind(r.p.ref, r.heme)
    n.sites = ncol(r.p.ref)
  } else {
    n.sites = n.aa
  }
  
  # Get the mean sequence identity 
  identity = mean(m.identity)
  n.sites.mut = as.integer((100 - (identity)) * n.aa / 100)
  
  ### CALCULATE ENM OF THE REFERENCE PROTEIN ###
  
  # Calculate K of p.ref
  ENMK.p.ref = CalculateENMK(r.p.ref, CalculateKij, R0, tolerance) 
  
  ### GENERATE MUTANTS ###
  
  # Create a matrix to save coordinates of each mutant
  m.r.mut = matrix(0, nrow = 3 * n.sites, ncol = n.prot * n.mut.p)
  
  # Create vectors to save simulated and accepted mutations of each mutant
  v.run = c()
  v.n.mut = c()
  v.site = c()
  v.CN = c()
  v.p.accept = c()
  v.accept = c()
  v.n.accept.mut = c()
  
  # Sart a counter for simulated proteins
  run = 0
  
  # Start a loop for each protein of the family
  for (P in (1:n.prot)) {
      
    # Start a loop to generate "n.mut.p" mutants for P
    for(mut in seq(n.mut.p)) {

      # Count the mut number
      run = run + 1

      print(list("beta" = beta, "P" = P, "mut" = mut))
        
      # create a vector with possible sites to mutate
      sites.to.mutate = seq(n.aa) 
        
      # Start a counter for simulated and accepted mutants
      n.mut = 0
      n.accept.mut = 0
        
      # Start "dr.tot"
      dr.tot = 0
        
      # Start a loop to generate mutations
      while (n.accept.mut < n.sites.mut) { 
          
        v.run = c(v.run, run)
        n.mut = n.mut + 1
        v.n.mut = c(v.n.mut, n.mut)
        
        # Get the index to mutate between 1 and the number of aminoacids
        mut.index = sample(sites.to.mutate, 1) 
        v.site = c(v.site, mut.index)
        
        # Get CN of mut.index
        CN.mut.index = sum(ENMK.p.ref$kij[, mut.index])
        v.CN = c(v.CN, CN.mut.index)
        
        # Calculate forces
        force = CalculateForce(mut.index, r.p.ref, ENMK.p.ref$kij, fmax) 
        f = force$f
        sum.fij.square = force$sum.fij.square
      
        # Calculate the acceptance probability of the mutation
        p.accept.mut = exp (- beta * sum.fij.square)
        v.p.accept = c(v.p.accept, p.accept.mut)
        
        if (p.accept.mut >= runif(1, 0, 1)) {
          
          v.accept = c(v.accept, 1)
          
          # Add to accepted mutants
          n.accept.mut = n.accept.mut + 1
            
          # Calculate "dr.mut" and "dr.tot"
          dr.mut = ENMK.p.ref$cov %*% f
          dr.tot = dr.tot + dr.mut
            
          # Remove "mut.index" from "sites.to.mutate" in order to not to mutate the same site more than once
          sites.to.mutate = sites.to.mutate[sites.to.mutate != mut.index]
        }else{
          v.accept = c(v.accept, 0)
        }
      }
        
      # Save n.accept.mut and n.mut for mut
      v.n.accept.mut = c(v.n.accept.mut, n.accept.mut)
      
      # Calculate "r.mut"
      r.mut = as.vector(r.p.ref) + dr.tot
      
      # Keep "r.mut" in a matrix
      m.r.mut[, n.mut.p * P - (n.mut.p - mut)] = r.mut
    }
  }
    
  ### SAVE INFORMATION IN FILES ###
  
  # Create a data.frame with information of each run 
  df.data = data.frame("run" = v.run, "n.mut" = v.n.mut, "site"= v.site, "CN" = v.CN, "p.accept" = v.p.accept, "accept" = v.accept) 
  
  # Create files to save the data
  write.csv(as.vector(r.p.ref), file = file.path(out.dir, paste(mut.fname.id, "_out_r.p.ref.csv", sep = "")), row.names = FALSE)
  write.csv(m.r.mut, file = file.path(out.dir, paste(mut.fname.id, "_out_m.r.mut.csv", sep = "")), row.names = FALSE)
  write.csv(v.n.accept.mut, file = file.path(out.dir, paste(mut.fname.id, "_out_v.n.accept.mut.csv", sep = "")), row.names = FALSE)
  write.csv(df.data, file = file.path(out.dir, paste(mut.fname.id, "_out_df.data.csv", sep = "")), row.names = FALSE)
}




